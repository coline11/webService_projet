
/**
 * Please modify this class to meet your needs
 * This class is not complete
 */

package com.newmusic.webservice.client;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;
import java.util.logging.Logger;
import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;
import javax.jws.WebService;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.ws.RequestWrapper;
import javax.xml.ws.ResponseWrapper;

import com.newmusic.webservice.resource.DistantWSAccess;

/**
 * This class was generated by Apache CXF 3.5.7
 * 2024-04-26T00:33:34.130+02:00
 * Generated source version: 3.5.7
 *
 */

@javax.jws.WebService(
                      serviceName = "MusicResourceWSService",
                      portName = "MusicResourceWSPort",
                      targetNamespace = "http://www.com.newmusic.webservice.resource",
                      wsdlLocation = "file:/C:/Users/Etudiant/eclipse-workspace-redo/com.newmusic.webservice/src/main/webapp/wsdl/musicresourcews.wsdl",
                      endpointInterface = "com.newmusic.webservice.client.MusicResourceWS")

public class MusicResourceWSPortImpl implements MusicResourceWS {

    private static final Logger LOG = Logger.getLogger(MusicResourceWSPortImpl.class.getName());

	// private static HashMap<Area, MusicEvent> upcomingEventsArea = new
	// HashMap<Area, MusicEvent>();

	private static HashMap<Artist, ArrayList<MusicEvent>> upcomingEventsArtist = new HashMap<Artist, ArrayList<MusicEvent>>();

	private static HashMap<Artist, ArrayList<Integer>> eventIdsByArtist = new HashMap<Artist, ArrayList<Integer>>();
	private static HashMap<Integer, Artist> artistById = new HashMap<Integer, Artist>();
	private static HashMap<Integer, HashMap<Integer, MusicEvent>> eventByIdByArtistId = new HashMap<Integer, HashMap<Integer, MusicEvent>>();

	/**
	 * Generates a new event id that has not already been used yet
	 * 
	 * @return An unused id
	 */
	private int getNewEventId(Artist a) {
		ArrayList<Integer> eventIds = eventIdsByArtist.get(a);

		// Since the event ids are stored in an arraylist, and this list is sorted
		// smallest to biggest, we just need to know the last number added
		if(eventIds.size() == 0) return 1;
		int newId = eventIds.get(eventIds.size() - 1) + 1;
		return newId;
	}

	/**
	 * Generates a new artist id that has not already been used yet
	 * 
	 * @return An unused id
	 */
	private int getNewArtistId() {
		Set<Integer> artistIds = artistById.keySet();
		int newId = 0;
		for (int id : artistIds) {
			if (newId < id) {
				newId = id;
			}
		}
		return ++newId;
	}

	/**
	 * Adds an upcoming event to the list. The event will be added to
	 * the pre-existing list and sorted according to its start date.
	 * 
	 * @param artistId The artist headlining the event
	 * @param event  The event to be added
	 * @return The {@link MusicEvent} added
	 */
	public Integer addUpcomingEvent(int artistId, MusicEvent event) {
		Artist artist = artistById.get(artistId);
		if(eventByIdByArtistId.get(artistId).containsValue(event)) {
			return -1;
		}
		
		int id = getNewEventId(artist);
		event.setEventId(id);
		
		upcomingEventsArtist.get(artist).add(event);
		eventIdsByArtist.get(artist).add(event.getEventId());
		eventByIdByArtistId.get(artist.getArtistsId()).put(id, event);
		return event.getEventId();
		// alme.sort(new SortByDate());
	}
	
	/**
	 * Adds an artist which does not exist yet, and sets its id.
	 * 
	 * @param artist The artist to add
	 * @return The Artist added
	 */
	public Integer addArtist(Artist artist) {
		com.newmusic.webservice.data.Artist copyA = new com.newmusic.webservice.data.Artist();
		copyA.setAlias(artist.getAlias());
		copyA.setArtistId(artist.getArtistsId());
		copyA.setCountry(artist.getCountry());
		copyA.setDead(artist.isDead());
		copyA.setDisambiguation(artist.getDisambiguation());
		copyA.setFirstName(artist.getFirstName());
		copyA.setGender(artist.getGender());
		copyA.setLastName(artist.getLastName());
		copyA.setName(artist.getFirstName(), artist.getLastName());
		
		copyA = DistantWSAccess.getArtist(copyA, !artist.getAlias().equals(""));
		artist.setAlias(copyA.getAlias());
		artist.setFirstName(copyA.getAlias());
		artist.setLastName(copyA.getAlias());
		artist.setCountry(copyA.getCountry());
		artist.setGender(copyA.getGender());
		artist.setDead(copyA.isDead());
		
		if(artistById.containsValue(artist)) {
			return -1;
		}
		
		int id = getNewArtistId();
		artist.setArtistId(id);

		upcomingEventsArtist.put(artist, new ArrayList<MusicEvent>());
		eventIdsByArtist.put(artist, new ArrayList<Integer>());
		eventByIdByArtistId.put(id, new HashMap<Integer, MusicEvent>());
		artistById.put(id, artist);
		return artist.getArtistsId();
	}

	/**
	 * Deletes the artist from the list of upcoming events
	 * 
	 * @param artistId The id of the artist to delete
	 * @return Whether or not the artist was successfully deleted
	 */
	public boolean deleteArtist(int artistId) {
		Artist artist = artistById.remove(artistId);
		eventByIdByArtistId.remove(artistId);
		eventIdsByArtist.remove(artist);
		boolean wasRemoved = upcomingEventsArtist.remove(artist) != null;
		return wasRemoved;
	}
	
	/**
	 * Deletes a specific event from an artist's upcoming event list
	 * 
	 * @param artistId The id of the artist headlining the event
	 * @param musicId The id of the event to delete
	 *  @return Whether or not the event was sucessfully deleted
	 */
	public boolean deleteEvent(int artistid, int eventId) {
		
		Integer artistId = artistid;
		Integer musicId = eventId;
		if(!artistById.containsKey(artistId)) {
			return false;
		}
		if(!eventByIdByArtistId.get(artistId).containsKey(musicId)) {
			return false;
		}
		Artist eventsArtist = artistById.get(artistId);
		MusicEvent event = eventByIdByArtistId.get(artistId).get(musicId);
		
		boolean allDeleted = true;
		allDeleted = allDeleted && upcomingEventsArtist.get(eventsArtist).remove(event);
		allDeleted = allDeleted && eventIdsByArtist.get(eventsArtist).remove(musicId);
		allDeleted = allDeleted && eventByIdByArtistId.get(artistId).remove(musicId, event);
		
		return allDeleted;
	}

	/**
	 * Find the {@link MusicEvent} based on the artist who headlined it and the
	 * event's unique identifier
	 * 
	 * @param artistId  The id of the artist
	 * @param eventId The music event's identifier
	 * @return The MusicEvent, if it exists, otherwise, null
	 */
	public MusicEvent getEvent(Integer artistId, Integer eventId) {
		//System.out.println(artistId + "; " + eventId);
		//System.out.println(eventByIdByArtistId);
		
		HashMap<Integer, MusicEvent> musicEvents = eventByIdByArtistId.get(artistId);
		
		//System.out.println(musicEvents);
		if(musicEvents == null) return null;
		return musicEvents.get(eventId);
	}
	
	/**
	 * Get all of an artist's events.
	 * @param artistId The id of the artist.
	 * @return All of the artist's events.
	 */
	public Artist getEvents(int artistId){
		Artist a = artistById.get(artistId);
		a.setEvents(new ArrayList<MusicEvent>(eventByIdByArtistId.get(artistId).values()));
		return a;
		
	}

	/**
	 * Get all events across all artists
	 * @return A {@link HashMap} associating an {@link Artist} to their {@link MusicEvent}s.
	 */
	public HashMap<Artist, ArrayList<MusicEvent>> getUpcomingEventsArtist() {
		return upcomingEventsArtist;
	}
	
	/**
	 * Get a specific {@link Artist}
	 * @param id The id of the {@link Artist}
	 * @return The {@link Artist}, or null if it doesn't exist
	 */
	public Artist getArtist(int id) {
		return artistById.get(id);
	}

	public MusicEvent getEvent(int artistId, int eventId) {
		// TODO Auto-generated method stub
		return null;
	}
}
